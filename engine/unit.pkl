open module unit
extends "gamepiece.pkl"
import "pkl:reflect"
import "parent_info.pkl" as ParentInfo
import "types.pkl" as $t
import "unit_upgrade.pkl" as UnitUpgrade
import "constructing_unit.pkl" as ConstructingUnit
import "unit.pkl" as me

local methis = this
local meref = reflect.moduleOf(this)

fixed type = "unit"
fixed subtype: String = unitType
hidden unitType: "army" | "hero" | "coop-commander" | "harvester" | "builder" | "special" | "ultimate" | "merc" | "merc-topbar" | "mobile-merc-outpost"

fixed dynamicTags {
  when (methis.canBeInfused) { "can-be-infused" }
  when (methis.canBeReanimated) { "can-be-reanimated" }
  when (methis.canBeMindControlled) { "can-be-mind-controlled" }
}

canBeInfused: Boolean = subtype == "army" || subtype == "merc" && !tags.toList().contains("massive")
canBeReanimated: Boolean = subtype == "army" || subtype == "merc" || subtype == "hero"
canBeMindControlled: Boolean = subtype != "hero"

hidden constructingVersion: Listing<ConstructingUnit> = new {
  default { key -> name = $t.makeSlug(key); parent = parentInfo; }
}

vision: Number? = 1800

variantUnits {
  when (canBeInfused) {
    ["\(methis.name) (Infused)"] = infusedForm
    ["\(methis.name) (Double Infused)"] = doubleInfusedForm
  }
  when (canBeReanimated) {
    ["\(methis.name) (Reanimated: Alive)"] = reanimatedAliveForm
    ["\(methis.name) (Reanimated: Zombie)"] = reanimatedZombieForm
  }
}
variantBuildings {
  when (constructingVersion.toList().length > 0) {
    ["\(methis.name) (Constructing)"] = constructingVersion.toList().first
  }
}

hidden infuseRule: Mixin<me> = new {
  appendSlug = "-infused"
  name = "\(super.name) (Infused)"
  hp = super.hp * 1.5

  abilities {
    for (nm, x in (super.abilities)) {
      [nm] = (x) {
        when ((x.abilityType == "attack" || x.abilityType == "heal") && x.damage != null) {
          damage = (x.damage ?? 0) * 1.5
        }
      }
    }
  }
}

hidden doubleInfuseRule: Mixin<me> = new {
  appendSlug = "-double-infused"
  name = "\(super.name) (Double Infused)"
  hp = super.hp * 2

  abilities {
    for (nm, x in (super.abilities)) {
      [nm] = (x) {
        when ((x.abilityType == "attack" || x.abilityType == "heal") && x.damage != null) {
          damage = (x.damage ?? 0) * 2
        }
      }
    }
  }
}

hidden reanimatedAliveRule: Mixin<me> = new {
  appendSlug = "-reanimated-alive"
  name = "\(super.name) (Reanimated: Alive)"
  speed = if (super.speed == null) null else super.speed * 1.3;

  abilities {
    for (nm, x in (super.abilities)) {
      [nm] = (x) {
        when ((x.abilityType == "attack" || x.abilityType == "heal") && x.cooldown != null) {
          cooldown = (x.cooldown ?? 0) * 0.7;
        }
      }
    }
  }
}

hidden reanimatedZombieRule: Mixin<me> = new {
  appendSlug = "-reanimated-zombie"
  name = "\(super.name) (Reanimated: Zombie)"
  speed = if (super.speed == null) null else super.speed / 0.7;

  abilities {
    for (nm, x in (super.abilities)) {
      [nm] = (x) {
        when ((x.abilityType == "attack" || x.abilityType == "heal") && x.cooldown != null) {
          cooldown = (x.cooldown ?? 0) / 1.3;
        }
      }
    }
  }
}

hidden fixed infusedForm: me? =
  if (tagList.toList().contains("infused") || !canBeInfused)
    null
  else
    (this |> infuseRule) {
      canBeInfused = false
      infuseCost = null
      infuseRule = null
      variantUnits {}
      variantBuildings {}
      tags { "infused" }
  }

hidden fixed doubleInfusedForm: me? =
  if (tagList.toList().contains("double-infused") || !canBeInfused)
    null
  else
    (this |> doubleInfuseRule) {
      canBeInfused = false
      infuseCost = null
      infuseRule = null
      variantUnits {}
      variantBuildings {}
      tags { "infused"; "double-infused" }
  }

hidden fixed reanimatedAliveForm: me? =
  if (tagList.toList().contains("reanimated-alive") || tagList.toList().contains("reanimated-zombie") || !canBeReanimated)
    null
  else
    (this |> reanimatedAliveRule) {
      canBeReanimated = false
      reanimateCost = null
      reanimatedAliveRule = null
      reanimatedZombieRule = null
      variantUnits {}
      variantBuildings {}
      tags { "reanimated-alive" }
    }

hidden fixed reanimatedZombieForm: me? =
  if (tagList.toList().contains("reanimated-zombie") || tagList.toList().contains("reanimated-alive") || !canBeReanimated)
    null
  else
    (this |> reanimatedZombieRule) {
      canBeReanimated = false
      reanimateCost = null
      reanimatedAliveRule = null
      reanimatedZombieRule = null
      variantUnits {}
      variantBuildings {}
      tags { "reanimated-zombie" }
    }

reanimateCost: Number? =
  if (!canBeReanimated)
    null
  else
    let (h = (hexiteCost ?? 0))
    let (f = (fluxCost ?? 0) * 1.25)
    let (n = (h + f) * 0.0675)
    (n * 10).round() / 10

infuseCost: Number? =
  if (!canBeInfused)
    null
  else
    let (s = (supply ?? 0))
    (s * 2).floor
    // let (h = (hexiteCost ?? 0))
    // let (f = (fluxCost ?? 0))
    // let (b = (buildCount ?? 1))
    // (((h + f) / b) / 10.0 ).floor + 1 // it may have been ceil but seedling cost was 1 before it was adjusted to 2 (seedling is 0 cost so 1 infuse means floor+1), but maybe 1 was a manual adjust and it was ceil all along


local parentInfo: ParentInfo = new {
  id = methis.id
  slug = methis.slug
  src = methis.src
  fromPath = methis.fromPath
}

hidden upgrades: Mapping<String, UnitUpgrade> = new Mapping<String, UnitUpgrade> {
  default { key -> name = key; parent = parentInfo; upgradeOf = methis.slug }
}
upgrade: Mapping<String, UnitUpgrade> = new {
  for (u in upgrades) { [u.slug] = u }
}

hidden fixed children = super.children +
  upgrades.toMap().values.toList() +
  (if (constructingForm != null)
    List(constructingVersion.toList().first)
  else
    List()) +
  if (infusedForm != null) List(infusedForm) else List()
