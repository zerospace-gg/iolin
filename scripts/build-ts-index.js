#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

// Get command line arguments
const args = process.argv.slice(2);
if (args.length < 1) {
  console.error("Usage: node build-ts-index.js <dist-dir>");
  process.exit(1);
}

const distDir = args[0];
const jsonDir = path.join(distDir, "json");
const tsDir = path.join(distDir, "typescript");

// Type mappings based on type/subtype combinations
function getTypeScriptType(type, subtype) {
  // Check for specific subtype mappings first
  if (type === "faction-ability") {
    if (subtype === "talent") return "FactionTalent";
    if (subtype === "topbar") return "FactionTopbar";
    if (subtype === "passive") return "FactionPassive";
  }

  // Use main type mapping
  const TYPE_MAPPINGS = {
    unit: "Unit",
    building: "Building",
    "add-on": "AddOn",
    ability: "Ability",
    "faction-ability": "FactionAbility",
    faction: "Faction",
    map: "RTSMap",
    "coop-mission": "CoopMission",
    "coop-level": "CoopLevel",
    "coop-commander": "CoopCommander",
    upgrade: "Upgrade",
    mutator: "Entity", // fallback to base Entity
  };

  return TYPE_MAPPINGS[type] || "Entity";
}

function generateImportName(slug) {
  return slug
    .split("-")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

function generateRelativeImportPath(toTsFile) {
  // Convert JSON path to TS path
  const tsPath = toTsFile.replace(/\.json$/, "");
  return `./${tsPath}`;
}

function generateCollectionFile(typeKey, groupData, allEntries) {
  const imports = [];
  const entries = [];

  // Export name mapping
  const exportNames = {
    unit: "Units",
    building: "Buildings",
    "add-on": "AddOns",
    ability: "Abilities",
    "faction-ability": "FactionAbilities",
    faction: "Factions",
    map: "Maps",
    "coop-mission": "CoopMissions",
    "coop-level": "CoopLevels",
    "coop-commander": "CoopCommanders",
    upgrade: "Upgrades",
    mutator: "Mutators",
  };

  const exportName =
    exportNames[typeKey] ||
    typeKey.charAt(0).toUpperCase() + typeKey.slice(1) + "s";

  groupData.entries.forEach((entry) => {
    const importName = generateImportName(entry.slug);
    const relativePath = entry.id.replace(/\//g, "/") + ".json";
    const importPath = generateRelativeImportPath(relativePath);

    imports.push(`import ${importName} from "${importPath}";`);
    entries.push({
      id: entry.id,
      importName: importName,
    });
  });

  const entriesStr = entries
    .map((entry) => `  "${entry.id}": ${entry.importName}`)
    .join(",\n");

  const content = `// Auto-generated ${exportName} collection
// This file is generated by build-ts-index.js - do not edit manually

import type { ${groupData.tsType} } from "./gg-iolin";

${imports.join("\n")}

export const ${exportName}: Record<string, ${groupData.tsType}> = {
${entriesStr}
};

export default ${exportName};
`;

  return content;
}

function generateMainIndexContent(typeGroups) {
  const content = `// Auto-generated main index file
// This file is generated by build-ts-index.js - do not edit manually

import Tags from "./tags";
import Release from "./release";
import Idx from "./idx";

// Export meta files
export { Tags, Release, Idx };

// Default export with meta
export default {
  Tags,
  Release,
  Idx,
};
`;

  return content;
}

function generateIdxMainFile(idxData) {
  const idEntries = Object.entries(idxData.all).map(([id, summary]) => ({
    slug: summary.slug,
    id: id,
  }));

  const idEntriesStr = idEntries
    .map((entry) => `  "${entry.slug}": "${entry.id}"`)
    .join(",\n");

  const allEntriesStr = Object.entries(idxData.all)
    .map(
      ([id, summary]) =>
        `  "${id}": ${JSON.stringify(summary, null, 2).replace(/\n/g, "\n  ")}`,
    )
    .join(",\n");

  const content = `// Auto-generated index - main entry point
// This file is generated by build-ts-index.js - do not edit manually

import type { MetaIdx, MetaIdxSummary } from "./gg-iolin";

// All entity summaries by ID
export const All: Record<string, MetaIdxSummary> = {
${allEntriesStr}
};

// Slug to ID mapping
export const Ids: Record<string, string> = {
${idEntriesStr}
};

const Idx: MetaIdx = {
  all: All,
  ids: Ids,
};

export default Idx;
`;

  return content;
}

function generateMetaFile(metaJsonPath, outputTsPath, typeName) {
  try {
    const jsonContent = fs.readFileSync(metaJsonPath, "utf8");
    const data = JSON.parse(jsonContent);

    const baseName = path.basename(outputTsPath, ".ts");
    const exportName = baseName.charAt(0).toUpperCase() + baseName.slice(1);

    const content = `// Auto-generated from ${path.basename(metaJsonPath)}

import type { ${typeName} } from "./gg-iolin";

const ${exportName}: ${typeName} = ${JSON.stringify(data, null, 2)};

export default ${exportName};
`;

    return content;
  } catch (error) {
    console.warn(`Warning: Could not generate ${outputTsPath}:`, error.message);
    return null;
  }
}

function copyTypeDefinitions() {
  const sourceTypes = path.join(__dirname, "..", "ext", "gg-iolin.d.ts");
  const destTypes = path.join(tsDir, "gg-iolin.d.ts");

  try {
    fs.copyFileSync(sourceTypes, destTypes);
    console.log(`Copied type definitions: ${destTypes}`);
  } catch (error) {
    console.warn(`Warning: Could not copy type definitions:`, error.message);
  }
}

async function formatWithPrettier(content) {
  try {
    const prettier = require("prettier");
    const formatted = await prettier.format(content, {
      parser: "typescript",
      semi: true,
      singleQuote: false,
      trailingComma: "all",
      tabWidth: 2,
    });
    return formatted;
  } catch (error) {
    console.warn("Warning: Prettier formatting failed, using original content");
    return content;
  }
}

async function main() {
  try {
    // Ensure typescript directory exists
    fs.mkdirSync(tsDir, { recursive: true });

    // Copy type definitions
    copyTypeDefinitions();

    // Load idx data
    const idxJsonPath = path.join(jsonDir, "idx.json");
    if (!fs.existsSync(idxJsonPath)) {
      throw new Error("Could not find idx.json data");
    }
    const idxJsonContent = fs.readFileSync(idxJsonPath, "utf8");
    const idxData = JSON.parse(idxJsonContent);

    console.log(
      `Found ${Object.keys(idxData.all).length} entities in idx data`,
    );

    // Generate meta files
    const metaFiles = [
      { file: "tags", type: "any" }, // You might want to define a proper type for this
      { file: "release", type: "MetaRelease" },
    ];

    for (const { file, type } of metaFiles) {
      const jsonPath = path.join(jsonDir, `${file}.json`);
      const tsPath = path.join(tsDir, `${file}.ts`);
      if (fs.existsSync(jsonPath)) {
        const content = generateMetaFile(jsonPath, tsPath, type);
        if (content) {
          const formattedContent = await formatWithPrettier(content);
          fs.writeFileSync(tsPath, formattedContent);
          console.log(`Generated meta file: ${tsPath}`);
        }
      }
    }

    // Process entities and group by type
    const typeGroups = {};

    Object.entries(idxData.all).forEach(([id, summary]) => {
      const tsType = getTypeScriptType(summary.type, summary.subtype);
      const typeKey = summary.type;

      if (!typeGroups[typeKey]) {
        typeGroups[typeKey] = {
          entries: [],
          tsType: tsType,
        };
      }

      typeGroups[typeKey].entries.push({
        id: id,
        slug: summary.slug,
      });
    });

    // Generate individual collection files
    for (const [typeKey, groupData] of Object.entries(typeGroups)) {
      const fileName =
        typeKey === "add-on"
          ? "addons"
          : typeKey === "faction-ability"
            ? "factionabilities"
            : typeKey === "coop-mission"
              ? "coopmissions"
              : typeKey === "coop-level"
                ? "cooplevels"
                : typeKey === "coop-commander"
                  ? "coopcommanders"
                  : typeKey + "s";

      const collectionPath = path.join(tsDir, `${fileName}.ts`);
      const collectionContent = generateCollectionFile(
        typeKey,
        groupData,
        idxData.all,
      );
      const formattedCollectionContent =
        await formatWithPrettier(collectionContent);
      fs.writeFileSync(collectionPath, formattedCollectionContent);
      console.log(`Generated collection file: ${collectionPath}`);
    }

    // Generate main idx.ts file (main entry point)
    const idxTsContent = generateIdxMainFile(idxData);
    const formattedIdxContent = await formatWithPrettier(idxTsContent);
    const idxPath = path.join(tsDir, "idx.ts");
    fs.writeFileSync(idxPath, formattedIdxContent);
    console.log(`Generated main idx file: ${idxPath}`);

    // Generate main index.ts with loaders
    const indexContent = generateMainIndexContent(typeGroups);
    const formattedIndexContent = await formatWithPrettier(indexContent);
    const indexPath = path.join(tsDir, "index.ts");
    fs.writeFileSync(indexPath, formattedIndexContent);
    console.log(`Generated main index: ${indexPath}`);

    console.log(`Total entities processed: ${Object.keys(idxData.all).length}`);
  } catch (error) {
    console.error("Error generating TypeScript index:", error.message);
    process.exit(1);
  }
}

main();
